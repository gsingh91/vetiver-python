[
  {
    "objectID": "reference/XGBoostHandler.html",
    "href": "reference/XGBoostHandler.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "XGBoostHandler()\nHandler class for creating VetiverModels with xgboost.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nxgboost.Booster\na trained and fit xgboost model\nrequired"
  },
  {
    "objectID": "reference/StatsmodelsHandler.html",
    "href": "reference/StatsmodelsHandler.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "StatsmodelsHandler()\nHandler class for creating VetiverModels with statsmodels.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nstatsmodels.api\na trained and fit statsmodels model\nrequired"
  },
  {
    "objectID": "reference/model_card.model_card.html",
    "href": "reference/model_card.model_card.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "model_card.model_card(path='.')\nCreate a model card for documentation\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nPath to save model card\n'.'\n\n\n\n\n\n\nThis model card is generated as a Quarto document. For more info on Quarto, visit https://quarto.org/"
  },
  {
    "objectID": "reference/BaseHandler.html",
    "href": "reference/BaseHandler.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "BaseHandler(self, model, prototype_data)\nBase handler class for creating VetiverModel of different type.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\n\na trained model\nrequired\n\n\nprototype_data\n\nAn object with information (data) whose layout is to be determined.\nrequired"
  },
  {
    "objectID": "reference/pin_metrics.html",
    "href": "reference/pin_metrics.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "pin_metrics(board, df_metrics, metrics_pin_name, pin_type=None, index_name='index', overwrite=False)\nUpdate an existing pin storing model metrics over time\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboard\n\nPins board\nrequired\n\n\ndf_metrics\npd.DataFrame\nDataframe of metrics over time, such as created by vetiver_compute_metrics()\nrequired\n\n\nmetrics_pin_name\nstr\nPin name for where the metrics are stored\nrequired\n\n\nindex_name\nstr\nThe column in df_metrics containing the aggregated dates or datetimes. Note that this defaults to a column named “index”.\n'index'\n\n\noverwrite\nbool\nIf True, overwrite any metrics for dates that exist both in the existing pin and new metrics with the new values. If False, error when the new metrics contain overlapping dates with the existing pin.\nFalse\n\n\n\n\n\n\n>>> import pins\n>>> import vetiver\n>>> df = pd.DataFrame(\n... {'index': {0: pd.Timestamp('2021-01-01 00:00:00'),\n...            1: pd.Timestamp('2021-01-01 00:00:00'),\n...            2: pd.Timestamp('2021-01-02 00:00:00'),\n...            3: pd.Timestamp('2021-01-02 00:00:00')},\n...  'n': {0: 1, 1: 1, 2: 1, 3: 1},\n...  'metric': {0: 'mean_squared_error',\n...             1: 'mean_absolute_error',\n...             2: 'mean_squared_error',\n...             3: 'mean_absolute_error'},\n...  'estimate': {0: 4.0, 1: 2.0, 2: 1.0, 3: 1.0}}\n... )\n>>> board = pins.board_temp()\n>>> board.pin_write(df, \"metrics\", type = \"csv\")\n>>> df = pd.DataFrame(\n... {'index': {0: pd.Timestamp('2021-01-02 00:00:00'),\n...            1: pd.Timestamp('2021-01-02 00:00:00'),\n...            2: pd.Timestamp('2021-01-03 00:00:00'),\n...            3: pd.Timestamp('2021-01-03 00:00:00')},\n...  'n': {0: 1, 1: 1, 2: 1, 3: 1},\n...  'metric': {0: 'mean_squared_error',\n...             1: 'mean_absolute_error',\n...             2: 'mean_squared_error',\n...             3: 'mean_absolute_error'},\n...  'estimate': {0: 4.0, 1: 6.0, 2: 2.0, 3: 1.0}}\n... )\n>>> vetiver.pin_metrics(\n...    board=board,\n...    df_metrics=df2,\n...    metrics_pin_name=\"metrics\",\n...    index_name=\"index\",\n...    overwrite=True)"
  },
  {
    "objectID": "reference/compute_metrics.html",
    "href": "reference/compute_metrics.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "compute_metrics(data, date_var, period, metric_set, truth, estimate, kw)\nCompute metrics for given time period\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\nDataFrame\nPandas dataframe\nrequired\n\n\ndate_var\nstr\nColumn in data containing dates\nrequired\n\n\nperiod\ndatetime.timedelta\nDefining period to group by\nrequired\n\n\nmetric_set\nlist\nList of metrics to compute, that have the parameters y_true and y_pred\nrequired\n\n\ntruth\nstr\nColumn name for true results\nrequired\n\n\nestimate\nstr\nColumn name for predicted results\nrequired\n\n\n\n\n\n\n>>> from datetime import timedelta\n>>> import pandas as pd\n>>> from sklearn.metrics import mean_squared_error, mean_absolute_error\n>>> df = pd.DataFrame(\n...   {\n...        \"index\": [\"2021-01-01\", \"2021-01-02\", \"2021-01-03\"],\n...        \"truth\": [200, 201, 199],\n...        \"pred\": [198, 200, 199],\n...   }\n... )\n>>> td = timedelta(days = 1)\n>>> metric_set = [mean_squared_error, mean_absolute_error]\n>>> metrics = compute_metrics(df, \"index\", td, metric_set, \"truth\", \"pred\")"
  },
  {
    "objectID": "reference/vetiver_create_prototype.html",
    "href": "reference/vetiver_create_prototype.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "vetiver_create_prototype(data)\nCreate zero row structure to save data types\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\nobject\nAn object with information (data) whose layout is to be determined.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nvetiver.Prototype\nData prototype"
  },
  {
    "objectID": "reference/VetiverAPI.run.html",
    "href": "reference/VetiverAPI.run.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "VetiverAPI.run(self, port=8000, host='127.0.0.1', kw)\nStart API\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nport\nint\nAn integer that indicates the server port that should be listened on.\n8000\n\n\nhost\nstr\nA valid IPv4 or IPv6 address, which the application will listen on.\n'127.0.0.1'\n\n\n\n\n\n\n>>> import vetiver as vt\n>>> X, y = vt.get_mock_data()\n>>> model = vt.get_mock_model().fit(X, y)\n>>> v = vt.VetiverModel(model = model, model_name = \"model\", prototype_data = X)\n>>> v_api = vt.VetiverAPI(model = v, check_prototype = True)\n>>> v_api.run()"
  },
  {
    "objectID": "reference/predict.html",
    "href": "reference/predict.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "predict(endpoint, data, kw)\nMake a prediction from model endpoint\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nendpoint\n\nURI path to endpoint\nrequired\n\n\ndata\nUnion[dict, pd.DataFrame, pd.Series]\nName of endpoint\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nEndpoint_name and list of endpoint_fx output\n\n\n\n\n\n\n>>> import vetiver\n>>> X, y = vetiver.get_mock_data()\n>>> endpoint = vetiver.vetiver_endpoint(url='http://127.0.0.1:8000/predict')\n>>> vetiver.predict(endpoint, X)"
  },
  {
    "objectID": "reference/deploy_rsconnect.html",
    "href": "reference/deploy_rsconnect.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "deploy_rsconnect(connect_server, board, pin_name, version=None, extra_files=None, new=False, app_id=None, title=None, python=None, conda_mode=False, force_generate=False, log_callback=None, image=None)\nDeploy to Posit Connect\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconnect_server\nrsconnect.api.RSConnectServer\nPosit Connect Server\nrequired\n\n\nboard\n\nPins board\nrequired\n\n\npin_name\nstr\nName of pin\nrequired\n\n\nversion\nstr\nVersion of pin\nNone\n\n\nextra_files\ntyping.List[str]\nAny extra files to include\nNone\n\n\nnew\nbool\nForce as a new deploy\nFalse\n\n\napp_id\nint\nID of an existing application to deploy new files for.\nNone\n\n\ntitle\nstr\nOptional title for the deploy.\nNone\n\n\npython\nstr\nOptional name of a Python executable\nNone\n\n\nconda_mode\nbool\nUse conda to build an environment.yml\nFalse\n\n\nforce_generate\nbool\nForce generating requirements.txt or environment.yml\nFalse\n\n\nlog_callback\ntyping.Callable\nCallback to use to write the log to\nNone\n\n\nimage\nstr\nDocker image to be specified for off-host execution\nNone\n\n\n\n\n\n\n>>> import vetiver\n>>> import pins\n>>> import rsconnect\n>>> board = pins.board_temp(allow_pickle_read=True)\n>>> connect_server = rsconnect.api.RSConnectServer(\n...    url = url,\n...    api_key = api_key)\n>>> X, y = vetiver.get_mock_data()\n>>> model = vetiver.get_mock_model().fit(X, y)\n>>> v = vetiver.VetiverModel(model = model,\n...    model_name = \"my_model\",\n...    prototype_data = X)\n>>> vetiver.deploy_rsconnect(\n...    connect_server = connect_server,\n...    board = board,\n...    pin_name = \"my_model\"\n... )"
  },
  {
    "objectID": "reference/prepare_docker.html",
    "href": "reference/prepare_docker.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "prepare_docker(board, pin_name, path='./', version=None, rspm_env=False, host='0.0.0.0', port='8080')\nCreate all files needed for Docker\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboard\n\nPin board for model\nrequired\n\n\npin_name\nstr\nName of pin\nrequired\n\n\npath\nstr\nPath to output\n'./'\n\n\nversion\n\nPin version to be used\nNone\n\n\nrspm_env\nbool\nWhether or not Posit Package Manager should be used\nFalse\n\n\nhost\nstr\nHost address to run VetiverAPI from Dockerfile\n'0.0.0.0'\n\n\nport\nstr\nPort to run VetiverAPI from Dockerfile\n'8080'\n\n\n\n\n\n\n>>> import vetiver\n>>> import tempfile\n>>> import pins\n>>> tmp = tempfile.TemporaryDirectory()\n>>> board = pins.board_temp(allow_pickle_read=True)\n>>> X, y = vetiver.get_mock_data()\n>>> model = vetiver.get_mock_model().fit(X, y)\n>>> v = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n>>> vetiver.vetiver_pin_write(board, v)\n>>> vetiver.prepare_docker(board = board, pin_name = \"my_model\", path = tmp.name)"
  },
  {
    "objectID": "reference/VetiverAPI.html",
    "href": "reference/VetiverAPI.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "VetiverAPI(self, model, check_prototype=True, app_factory=FastAPI, kwargs)\nCreate model aware API\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nVetiverModel\nModel to be deployed in API\nrequired\n\n\ncheck_prototype\nbool\nDetermine if data prototype should be enforced\nTrue\n\n\napp_factory\n\nType of API to be deployed\nFastAPI\n\n\n**kwargs\n\nDeprecated parameters.\n{}\n\n\n\n\n\n\n>>> import vetiver as vt\n>>> X, y = vt.get_mock_data()\n>>> model = vt.get_mock_model().fit(X, y)\n>>> v = vt.VetiverModel(model = model, model_name = \"my_model\", prototype_data = X)\n>>> v_api = vt.VetiverAPI(model = v, check_prototype = True)\n\n\n\nParameter check_ptype was changed to check_prototype. Handling of check_ptype will be removed in a future version."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "VetiverModel\nCreate VetiverModel class for serving.\n\n\nvetiver_pin_write\nPin a trained VetiverModel along with other model metadata.\n\n\nvetiver_create_prototype\nCreate zero row structure to save data types\n\n\nmodel_card.model_card\nCreate a model card for documentation\n\n\n\n\n\n\n\n\n\nVetiverAPI\nCreate model aware API\n\n\nVetiverAPI.run\nStart API\n\n\nVetiverAPI.vetiver_post\nCreate new POST endpoint that is aware of model input data\n\n\nvetiver_endpoint\nWrap url where VetiverModel will be deployed\n\n\npredict\nMake a prediction from model endpoint\n\n\nwrite_app\nWrite VetiverAPI app to a file\n\n\nprepare_docker\nCreate all files needed for Docker\n\n\nwrite_docker.write_docker\nWrites a Dockerfile to run VetiverAPI in a container\n\n\ndeploy_rsconnect\nDeploy to Posit Connect\n\n\n\n\n\n\n\n\n\ncompute_metrics\nCompute metrics for given time period\n\n\npin_metrics\nUpdate an existing pin storing model metrics over time\n\n\nplot_metrics\nPlot metrics over a given time period\n\n\n\n\n\n\n\n\n\nBaseHandler\nBase handler class for creating VetiverModel of different type.\n\n\nSKLearnHandler\nHandler class for creating VetiverModels with sklearn.\n\n\nTorchHandler\nHandler class for creating VetiverModels with torch.\n\n\nStatsmodelsHandler\nHandler class for creating VetiverModels with statsmodels.\n\n\nXGBoostHandler\nHandler class for creating VetiverModels with xgboost."
  },
  {
    "objectID": "reference/TorchHandler.html",
    "href": "reference/TorchHandler.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "TorchHandler()\nHandler class for creating VetiverModels with torch.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nnn.Module\na trained torch model\nrequired"
  },
  {
    "objectID": "reference/SKLearnHandler.html",
    "href": "reference/SKLearnHandler.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "SKLearnHandler()\nHandler class for creating VetiverModels with sklearn.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nsklearn.base.BaseEstimator\na trained sklearn model\nrequired"
  },
  {
    "objectID": "reference/vetiver_pin_write.html",
    "href": "reference/vetiver_pin_write.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "vetiver_pin_write(board, model, versioned=True)\nPin a trained VetiverModel along with other model metadata.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboard\n\nA pin board, created by pins.board_folder() or another board_ function.\nrequired\n\n\nmodel\nvetiver.vetiver_model.VetiverModel\nVetiverModel to be written to board\nrequired\n\n\nversioned\nbool\nWhether or not the pin should be versioned\nTrue\n\n\n\n\n\n\n>>> import vetiver\n>>> from pins import board_temp\n>>> model_board = board_temp(versioned = True, allow_pickle_read = True)\n>>> X, y = vetiver.get_mock_data()\n>>> model = vetiver.get_mock_model().fit(X, y)\n>>> v = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n>>> vetiver.vetiver_pin_write(model_board, v)"
  },
  {
    "objectID": "reference/write_app.html",
    "href": "reference/write_app.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "write_app(board, pin_name, version=None, file='app.py', overwrite=False)\nWrite VetiverAPI app to a file\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboard\n\nAPI to be written\nrequired\n\n\npin_name\nstring\nName of pin containing VetiverModel\nrequired\n\n\nversion\nstr\nPins version of VetiverModel\nNone\n\n\nfile\nstr\nName of file\n'app.py'\n\n\n\n\n\n\n>>> import vetiver\n>>> import tempfile\n>>> import pins\n>>> tmp = tempfile.TemporaryDirectory()\n>>> board = pins.board_temp(allow_pickle_read=True)\n>>> X, y = vetiver.get_mock_data()\n>>> model = vetiver.get_mock_model().fit(X, y)\n>>> v = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n>>> vetiver.vetiver_pin_write(board, v)\n>>> vetiver.write_app(board,\n...     \"my_model\",\n...     file = tmp.name + \"/app.py\")"
  },
  {
    "objectID": "reference/write_docker.write_docker.html",
    "href": "reference/write_docker.write_docker.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "write_docker.write_docker(app_file='app.py', path='./', rspm_env=False, host='0.0.0.0', port='8080')\nWrites a Dockerfile to run VetiverAPI in a container\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\napp_file\nstr\nFile containing VetiverAPI to be deployed into container\n'app.py'\n\n\npath\nstr\nPath to save Dockerfile\n'./'\n\n\nrspm_env\nbool\nWhether or not Posit Package Manager should be used\nFalse\n\n\nhost\nstr\nHost address to run VetiverAPI from Dockerfile\n'0.0.0.0'\n\n\nport\nstr\nPort to run VetiverAPI from Dockerfile\n'8080'\n\n\n\n\n\n\n>>> import vetiver\n>>> import tempfile\n>>> import pins\n>>> tmp = tempfile.TemporaryDirectory()\n>>> board = pins.board_temp(allow_pickle_read=True)\n>>> X, y = vetiver.get_mock_data()\n>>> model = vetiver.get_mock_model().fit(X, y)\n>>> v = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n>>> vetiver.vetiver_pin_write(board, v)\n>>> vetiver.write_app(board,\n...     \"my_model\",\n...     file = tmp.name + \"/app.py\") # need file for model\n>>> vetiver.write_docker(app_file = \"app.py\", path = tmp.name)"
  },
  {
    "objectID": "reference/VetiverAPI.vetiver_post.html",
    "href": "reference/VetiverAPI.vetiver_post.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "VetiverAPI.vetiver_post(self, endpoint_fx, endpoint_name=None, kw)\nCreate new POST endpoint that is aware of model input data\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nendpoint_fx\ntyping.Callable\nCustom function to be run at endpoint\nrequired\n\n\nendpoint_name\nstr\nName of endpoint\nNone\n\n\n\n\n\n\n>>> import vetiver as vt\n>>> X, y = vt.get_mock_data()\n>>> model = vt.get_mock_model().fit(X, y)\n>>> v = vt.VetiverModel(model = model, model_name = \"model\", prototype_data = X)\n>>> v_api = vt.VetiverAPI(model = v, check_prototype = True)\n>>> def sum_values(x):\n...     return x.sum()\n>>> v_api.vetiver_post(sum_values, \"sums\")"
  },
  {
    "objectID": "reference/plot_metrics.html",
    "href": "reference/plot_metrics.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "plot_metrics(df_metrics, date='index', estimate='estimate', metric='metric', n='n', kw)\nPlot metrics over a given time period\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndf_metrics\nDataFrame\nPandas dataframe of metrics over time, such as created by compute_metrics()\nrequired\n\n\ndate\n\nColumn in df_metrics containing dates\n'index'\n\n\nestimate\n\nColumn in df_metrics containing metric output\n'estimate'\n\n\nmetric\n\nColumn in df_metrics containing metric name\n'metric'\n\n\nn\n\nColumn in df_metrics containing number of observations\n'n'\n\n\n\n\n\n\n>>> import vetiver\n>>> import pandas as pd\n>>> df = pd.DataFrame(\n... {'index': {0: pd.Timestamp('2021-01-01 00:00:00'),\n...            1: pd.Timestamp('2021-01-01 00:00:00'),\n...            2: pd.Timestamp('2021-01-02 00:00:00'),\n...            3: pd.Timestamp('2021-01-02 00:00:00')},\n...  'n': {0: 1, 1: 1, 2: 1, 3: 1},\n...  'metric': {0: 'mean_squared_error',\n...             1: 'mean_absolute_error',\n...             2: 'mean_squared_error',\n...             3: 'mean_absolute_error'},\n...  'estimate': {0: 4.0, 1: 2.0, 2: 1.0, 3: 1.0}}\n... )\n>>> plot = vetiver.plot_metrics(\n...     df_metrics = df,\n...     date = \"index\",\n...     estimate = \"estimate\",\n...     metric = \"metric\",\n...     n = \"n\")\n>>> plot.show()"
  },
  {
    "objectID": "reference/VetiverModel.html",
    "href": "reference/VetiverModel.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "VetiverModel(self, model, model_name, prototype_data=None, versioned=None, description=None, metadata=None, kwargs)\nCreate VetiverModel class for serving.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\n\nA trained model, such as an sklearn or torch model\nrequired\n\n\nmodel_name\nstring\nModel name or ID\nrequired\n\n\nprototype_data\npd.DataFrame, np.array\nSample of data model should expect when it is being served\nNone\n\n\nversioned\n\nShould the model be versioned when created?\nNone\n\n\ndescription\nstr\nA detailed description of the model. If omitted, a brief description will be generated.\nNone\n\n\nmetadata\ndict\nOther details to be saved and accessed for serving\nNone\n\n\n**kwargs\n\nDeprecated parameters.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprototype\nvetiver.Prototype\nData prototype\n\n\nhandler_predict\nCallable\nMethod to make predictions from a trained model\n\n\n\n\n\n\nVetiverModel can also take an initialized custom VetiverHandler as a model, for advanced use cases or non-supported model types. Parameter ptype_data was changed to prototype_data. Handling of ptype_data will be removed in a future version.\n\n\n\n>>> from vetiver import mock, VetiverModel\n>>> X, y = mock.get_mock_data()\n>>> model = mock.get_mock_model().fit(X, y)\n>>> v = VetiverModel(model = model, model_name = \"my_model\", prototype_data = X)\n>>> v.description\n'A scikit-learn DummyRegressor model'"
  },
  {
    "objectID": "reference/vetiver_endpoint.html",
    "href": "reference/vetiver_endpoint.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "vetiver_endpoint(url='http://127.0.0.1:8000/predict')\nWrap url where VetiverModel will be deployed\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nurl\nstr\nURI path to endpoint\n'http://127.0.0.1:8000/predict'\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nURI path to endpoint\n\n\n\n\n\n\n>>> import vetiver\n>>> endpoint = vetiver.vetiver_endpoint(url='http://127.0.0.1:8000/predict')"
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "For full details, view the commit logs.\n\n\n\n\nFull Changelog\n\nDOC: Added missing model_name to VetiverModel in GH128\nBUG, MAINT: Catch non 200 codes in GH129\nDOC: fix deploy_rsconnect example in GH1234\nENH: Make vetiver_post extensible for all endpoints in GH130\nTEST: ci testing to run generated dockerfile in GH136\nMAINT: rsconnect-python>=1.8.0 in GH132\nENH: New prepare_docker function in GH137\nDOC: refresh README and add to docs in GH141\nTEST: Update weekly tests: only run necessary tests in GH142\nMAINT: update ptype_data to prototype_data in GH138\nENH: Refactor metadata in GH126\nMAINT: remove stars for explicit imports in GH145\nDOC: Changing language from “Example” to “Examples” for docstrings in GH146\nENH: Added Python version to vetiver_pin_write in GH127\n\n\n\n\n\n\n\nFull Changelog\n\nTEST: pins<>vetiver compatibility test in GH113\nTEST: Update weekly tests to include rsconnect-python in GH117\nDOC: Missing whitespace in InvalidModelError in GH120\nMAINT: Remove xfail from test_rsconnect in GH119\nMAINT: Add httpx in GH125\nENH: Add pin URL to REST API and metadata in GH123\n\n\n\n\n\n\n\nFull Changelog\n\nENH, DOC: have stable and latest docs in GH93\nBUG: bug fix for load_pkgs function on Windows OS in GH98\nMAINT: Update attach_pkgs.py in GH99\nENH: implement statsmodels handler in GH100\nFEAT: xgboost handler in GH101\nENH: adding model card template in GH106\nBUG: refactor pseudo version to pin_url in model card in GH107\nDOC: adding docs, small refactoring in GH108\nENH, DOC: add examples to docstrings in GH109\n\n\n\n\n\n\n\nFull Changelog\n\nENH: add rsconnect_deploy support for board_folder in GH77\nENH: model monitoring in GH76\nDOC: add mini chicago dataset in GH81\nMAINT: remove trailing slashes in API paths GH\nENH: explicitly add n to hover data in plot_metrics in GH84\nENH: initial vetiver_pin_metrics implementation in GH82\nMAINT, ENH: Use setuptools_scm for tagged versioning in GH86\nENH: handlers to register themselves in GH87\nBUG: coerce date var to datetime in GH89"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "Vetiver, the oil of tranquility, is used as a stabilizing ingredient in perfumery to preserve more volatile fragrances.\nThe goal of vetiver is to provide fluent tooling to version, share, deploy, and monitor a trained model. Functions handle both recording and checking the model’s input data prototype, and predicting from a remote API endpoint. The vetiver package is extensible, with generics that can support many kinds of models, and available for both Python and R. To learn more about vetiver, see:\n\nthe documentation at https://vetiver.rstudio.com/\nthe R package at https://rstudio.github.io/vetiver-r/\n\nYou can use vetiver with:\n\nscikit-learn\ntorch\nstatsmodels\nxgboost\nor utilize custom handlers to support your own models!\n\n\n\nYou can install the released version of vetiver from PyPI:\npython -m pip install vetiver\nAnd the development version from GitHub with:\npython -m pip install git+https://github.com/rstudio/vetiver-python\n\n\n\nA VetiverModel() object collects the information needed to store, version, and deploy a trained model.\nfrom vetiver import mock, VetiverModel\n\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\n\nv = VetiverModel(model, model_name='mock_model', prototype_data=X)\nYou can version and share your VetiverModel() by choosing a pins “board” for it, including a local folder, RStudio Connect, Amazon S3, and more.\nfrom pins import board_temp\nfrom vetiver import vetiver_pin_write\n\nmodel_board = board_temp(versioned = True, allow_pickle_read = True)\nvetiver_pin_write(model_board, v)\nYou can deploy your pinned VetiverModel() using VetiverAPI(), an extension of FastAPI.\nfrom vetiver import VetiverAPI\napp = VetiverAPI(v, check_prototype = True)\nTo start a server using this object, use app.run(port = 8080) or your port of choice.\n\n\n\nThis project is released with a Contributor Code of Conduct. By contributing to this project, you agree to abide by its terms.\n\nFor questions and discussions about deploying models, statistical modeling, and machine learning, please post on RStudio Community.\nIf you think you have encountered a bug, please submit an issue."
  },
  {
    "objectID": "custom_handler.html",
    "href": "custom_handler.html",
    "title": "Vetiver (Python)",
    "section": "",
    "text": "Custom Handlers\nThere are two different ways that vetiver supports flexible handling for models that do not work automatically with the vetiver framework. The first way is with new model types where there is no current implementation for the type of model you would like to deploy. The second way is when you would like to implement a current handler, but in a different way. In either case, you should create a custom handler from vetiver’s BaseHandler(). At a minimum, you must give the type of your model via model_type how predictions should be made, via the method handler_predict(). Then, initialize your handler with your model, and pass the object into VetiverModel.\nThis example shows a custom handler of newmodeltype type.\nfrom vetiver.handlers.base import BaseHandler\n\nclass CustomHandler(BaseHandler):\n    def __init__(self, model, ptype_data):\n        super().__init__(model, ptype_data)\n\n    model_type = staticmethod(lambda: newmodeltype)\n    pip_name = \"scikit-learn\" # pkg name on pip, used for tracking pkg versions\n\n    def handler_predict(self, input_data, check_ptype: bool):\n        \"\"\"\n        Generates method for /predict endpoint in VetiverAPI\n\n        The `handler_predict` function executes at each API call. Use this\n        function for calling `predict()` and any other tasks that must be executed at each API call.\n\n        Parameters\n        ----------\n        input_data:\n            Test data\n        check_ptype: bool\n            Whether the ptype should be enforced\n\n        Returns\n        -------\n        prediction\n            Prediction from model\n        \"\"\"\n        # your code here\n        prediction = model.fancy_new_predict(input_data)\n\n        return prediction\n\nnew_model = CustomHandler(model, ptype_data)\n\nVetiverModel(new_model, \"custom_model\")\nIf your model is a common type, please consider submitting a pull request."
  }
]